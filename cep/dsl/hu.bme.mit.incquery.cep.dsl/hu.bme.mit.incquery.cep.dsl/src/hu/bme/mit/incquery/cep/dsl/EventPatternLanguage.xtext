grammar hu.bme.mit.incquery.cep.dsl.EventPatternLanguage with org.eclipse.xtext.xbase.Xbase // with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/incquery/patternlanguage/PatternLanguage" as iqpl
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eventPatternLanguage "http://www.bme.hu/mit/incquery/cep/dsl/EventPatternLanguage"

EventModel hidden(WS, ML_COMMENT, SL_COMMENT):
	('package' packageName=QualifiedName)?
	usages+=Usage*
	'EventModel' name=ID '{'
		events+=ModelElements*
	'}';

DOUBLE returns ecore::EDouble:
	('-')? INT('.' INT)?;

//QualifiedName:
//	ID ('.' ID)*;
//
//QualifiedNameWithWildcard:
//	QualifiedName '.*'?;

Usage:
	IQUsage | EventSourceUsage;

IQUsage:
	'uses-incquery-patterns' importedNamespace=QualifiedNameWithWildcard;

EventSourceUsage:
	'uses-eventsources' importedNamespace=QualifiedNameWithWildcard;

ModelElements:
	Event | Rule | Source
;

Event:
	AbstractAtomicEvent | ComplexEvent;

AbstractAtomicEvent:
	AtomicEvent | IQPatternEvent;

AtomicEvent:
	'AtomicEvent' name=ID '()' '{'
		'source' ':' source=[Source]
		'parameterFilters' '{'
			parameterFilters+=ParameterFilter+
		'}'
	'}';

IQPatternEvent:
	'IQPatternEvent' name=ID '()' '{'
		'incQueryPatternRef' ':' iqpattern=STRING//[iqpl::Pattern]
		'changeType' ':' changeType=IQPatternChangeType
	'}';

ComplexEvent:
	'ComplexEvent' name=ID paramlist=CEParamlist '{'
		'priority'':' priority=INT
		complexEventExpressions+=ComplexEventExpression*
	'}';

Rule:
	'Rule' (name=ID)? '{'
		'events' ':' events+=[Event] (', 'events+=[Event])*
		'action' '{'
			action = XExpression
		'}'
	'}'
;

CEParamlist:
	{CEParamlist}
	'(' params+=EventParamWithType (', 'params+=EventParamWithType)* ')';

EventParamWithType:
	name=ID ':' type=[Event];

ParameterFilter:
	attributeName=ID paramFilterRule=ParameterFilterRule;

enum IQPatternChangeType:
	FOUND | LOST;




ParameterFilterRule:
	RangeFilter | NumericFilter | LiteralFilter;

RangeFilter:
	(neg=NegationOpartor)? "in" range=Range;

Range:
	OpenOpen | OpenClosed | ClosedClosed | ClosedOpen;

OpenOpen:
	'(' lowerBound=DOUBLE ',' upperBound=DOUBLE ')';

OpenClosed:
	'(' lowerBound=DOUBLE ',' upperBound=DOUBLE ']';

ClosedClosed:
	'[' lowerBound=DOUBLE ',' upperBound=DOUBLE ')';

ClosedOpen:
	'[' lowerBound=DOUBLE ',' upperBound=DOUBLE ']';

NumericFilter:
	operator=NumericOperator value=DOUBLE;

NumericOperator:
	'<' | '=<' | '==' | '!=' | '>=' | '>';

LiteralFilter:
	(neg=NegationOpartor)? operator=LiteralOperator value=STRING;

LiteralOperator:
	'contains' | 'startsWith' | 'endsWith';

NegationOpartor:
	'not';

ComplexEventExpression:
	FollowsExpression
;

FollowsExpression:
	firstEvent+=EventWithMultiplicity (events+=EventWithFollowsOperator)*;

EventWithFollowsOperator:
	operator=FollowsOperator event=FollowerEventStructure;

FollowsOperator:
	FollowsOperatorNoTW | FollowsOperatorViaTW;

FollowsOperatorNoTW:
	{FollowsOperatorNoTW}
	'->';

FollowsOperatorViaTW:
	'-[' timewindow=INT ']->';

FollowerEventStructure:
	BranchExpression | EventWithMultiplicity
;

BranchExpression:
	'('branches+=[EventParamWithType] ('OR' branches+=[EventParamWithType])+')'
;

EventWithMultiplicity:
	event=[EventParamWithType] ('{' multiplicity=INT '}')?;
	
Source:
	'Source' name=ID '{'
		('register' adapter+=Adapter)+
	'}'
;

Adapter:
	name=STRING
;