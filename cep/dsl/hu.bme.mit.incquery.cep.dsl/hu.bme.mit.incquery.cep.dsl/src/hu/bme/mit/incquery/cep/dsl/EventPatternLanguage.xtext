grammar hu.bme.mit.incquery.cep.dsl.EventPatternLanguage with org.eclipse.xtext.xbase.Xbase // with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/incquery/patternlanguage/PatternLanguage" as iqpl
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eventPatternLanguage "http://www.bme.hu/mit/incquery/cep/dsl/EventPatternLanguage"

EventModel hidden(WS, ML_COMMENT, SL_COMMENT):
	('package' packageName=QualifiedName)?
	usages+=Usage*
	annotations+=Annotations*
	'EventModel' name=ID '{'
		events+=EventModelElements*
	'}';

DOUBLE returns ecore::EDouble:
	('-')? INT('.' INT)?;

//QualifiedName:
//	ID ('.' ID)*;
//
//QualifiedNameWithWildcard:
//	QualifiedName '.*'?;

Usage:
	IQUsage | EventSourceUsage;

IQUsage:
	'uses-incquery-patterns' importedNamespace=QualifiedNameWithWildcard;

EventSourceUsage:
	'uses-eventsources' importedNamespace=QualifiedNameWithWildcard;

EventModelElements:
	Event | Source
;

Event:
	AbstractAtomicEvent | ComplexEvent;

AbstractAtomicEvent:
	AtomicEvent | IQPatternEvent;

AtomicEvent:
	annotations+=Annotations*
	'AtomicEvent' name=ID '()' '{'
		'id' ':' id=STRING
		'source' ':' source=[Source]
		'parameterFilters' '{'
			parameterFilters+=ParameterFilter+
		'}'
	'}';

IQPatternEvent:
	'IQPatternEvent' name=ID '()' '{'
		'IQPatternRef' ':' iqpattern=STRING//[iqpl::Pattern]
		'ChangeType' ':' changeType=IQPatternChangeType
	'}';

ComplexEvent:
	annotations+=Annotations*
	'ComplexEvent' name=ID paramlist=CEParamlist '{'
		complexEventExpressions+=ComplexEventExpression*
	'}';

CEParamlist:
	{CEParamlist}
	'(' params+=EventParamWithType* ')';

EventParamWithType:
	name=ID ':' type=[Event];

ParameterFilter:
	attributeName=ID paramFilterRule=ParameterFilterRule;

enum IQPatternChangeType:
	FOUND | LOST;

Annotations:
	ContextAnnotation | SamplingAnnotation | PriorityAnnotation;

ContextAnnotation:
	'@Context' '(' context=Context ')';

enum Context:
	Chronicle | Recent | Unrestricted;

SamplingAnnotation:
	'@SamplingTime' '(' sampling=INT ')';

PriorityAnnotation:
	'@Priority' '(' priority=INT ')';

ParameterFilterRule:
	RangeFilter | NumericFilter | LiteralFilter;

RangeFilter:
	(neg=NegationOpartor)? "in" range=Range;

Range:
	OpenOpen | OpenClosed | ClosedClosed | ClosedOpen;

OpenOpen:
	'(' lowerBound=DOUBLE ',' upperBound=DOUBLE ')';

OpenClosed:
	'(' lowerBound=DOUBLE ',' upperBound=DOUBLE ']';

ClosedClosed:
	'[' lowerBound=DOUBLE ',' upperBound=DOUBLE ')';

ClosedOpen:
	'[' lowerBound=DOUBLE ',' upperBound=DOUBLE ']';

NumericFilter:
	operator=NumericOperator value=DOUBLE;

NumericOperator:
	'<' | '=<' | '==' | '!=' | '>=' | '>';

LiteralFilter:
	(neg=NegationOpartor)? operator=LiteralOperator value=STRING;

LiteralOperator:
	'contains' | 'startsWith' | 'endsWith';

NegationOpartor:
	'not';

ComplexEventExpression:
	FollowsExpression //| ConcurrentExpression
;

FollowsExpression:
	firstEvent+=EventWithMultiplicity (events+=EventWithFollowsOperator)*;

EventWithFollowsOperator:
	operator=FollowsOperator event=EventWithMultiplicity;

FollowsOperator:
	FollowsOperatorNoTW | FollowsOperatorViaTW;

FollowsOperatorNoTW:
	{FollowsOperatorNoTW}
	'->';

FollowsOperatorViaTW:
	'-[' timewindow=INT ']->';

EventWithMultiplicity:
	event=[EventParamWithType] ('{' multiplicity=INT '}')?;
	
Source:
	'source' name=ID '{'
		('register' adapter+=Adapter)+
	'}'
;

Adapter:
	name=STRING
;