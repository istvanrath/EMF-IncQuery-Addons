grammar hu.bme.mit.incquery.cep.dsl.EventPatternLanguage with org.eclipse.xtext.xbase.Xbase // with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/incquery/patternlanguage/PatternLanguage" as iqpl
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eventPatternLanguage "http://www.bme.hu/mit/incquery/cep/dsl/EventPatternLanguage"

EventModel:
	('package' packageName=QualifiedName)?
	usages+=Usage*
	'EventModel' name=ID '{'
		events+=ModelElements*
	'}';

DOUBLE returns ecore::EDouble:
	('-')? INT('.' INT)?;

//QualifiedName:
//	ID ('.' ID)*;
//
//QualifiedNameWithWildcard:
//	QualifiedName '.*'?;

Usage:
	IQUsage | EventSourceUsage;

IQUsage:
	'uses-incquery-patterns' importedNamespace=QualifiedNameWithWildcard;

EventSourceUsage:
	'uses-eventsources' importedNamespace=QualifiedNameWithWildcard;

ModelElements:
	Event | Rule | Source
;

Event:
	AbstractAtomicEvent | ComplexEvent;


/*******************************************BASIC EVENT TYPE ELEMENTS*******************************************/
AbstractAtomicEvent:
	AtomicEvent | IQPatternEvent;
	
AtomicEvent:
	'AtomicEvent' name=ID '('parameters=TypedParameterList?')' '{'
		'source' ':' source=[Source]
		'staticBinding' '{'
			staticBindings += StaticBinding*
		'}'
	'}';
	
IQPatternEvent:
	'IQPatternEvent' name=ID '('parameters=TypedParameterList?')' '{'
		'iqPatternRef' ':' iqpattern=STRING//[iqpl::Pattern]
		'iqChangeType' ':' changeType=IQPatternChangeType
	'}';


ComplexEvent:
	'ComplexEvent' name=ID '('parameters=EventParameterList?')' '{'
		'priority'':' priority=INT
		'definition'':'complexEventExpressions+=ComplexEventExpression*
	'}';

Rule:
	'Rule' (name=ID)? '{'
		'events' ':' events+=[Event] (', 'events+=[Event])*
		'action' '{'
			action = XExpression
		'}'
	'}'
;
/*******************************************BASIC EVENT TYPE ELEMENTS*******************************************/
	
	
	
/*******************************************IQ PATTERN ELEMENTS*******************************************/
enum IQPatternChangeType:
	FOUND | LOST;
/*******************************************IQ PATTERN ELEMENTS*******************************************/



/*******************************************FUNCTION ARGUMEN PARAMETERS*******************************************/
TypedParameterList:
	{TypedParameterList}
	parameters+=TypedParameter (', ' parameters+=TypedParameter)*
;

TypedParameter:
	{TypedParameter}
	name=ID ':' type = JvmTypeReference
;

EventParameterList:
	{EventParameterList}
	parameters+=EventTypedParameter (', ' parameters+=EventTypedParameter)*
;

EventTypedParameter:
	{EventTypedParameter}
	name=ID ':' type=[Event];
/*******************************************FUNCTION ARGUMEN PARAMETERS*******************************************/


/*******************************************STATIC BINDING ELEMENTS*******************************************/
StaticBinding:
	parameter=[TypedParameter] bindingRule=StaticBindingRule;

StaticBindingRule:
	RangeFilter | NumericFilter | LiteralFilter;

RangeFilter:
	(neg=NegationOpartor)? "in" range=Range;

Range:
	OpenOpen | OpenClosed | ClosedClosed | ClosedOpen;

OpenOpen:
	'(' lowerBound=DOUBLE ', ' upperBound=DOUBLE ')';

OpenClosed:
	'(' lowerBound=DOUBLE ', ' upperBound=DOUBLE ']';

ClosedClosed:
	'[' lowerBound=DOUBLE ', ' upperBound=DOUBLE ')';

ClosedOpen:
	'[' lowerBound=DOUBLE ', ' upperBound=DOUBLE ']';

NumericFilter:
	operator=NumericOperator value=DOUBLE;

NumericOperator:
	'<' | '=<' | '==' | '!=' | '>=' | '>';

LiteralFilter:
	(neg=NegationOpartor)? operator=LiteralOperator value=STRING;

LiteralOperator:
	'contains' | 'startsWith' | 'endsWith';

NegationOpartor:
	'not';
/*******************************************STATIC BINDING ELEMENTS*******************************************/


/*******************************************COMPLEX EVENT EXPRESSIONS*******************************************/
ComplexEventExpression:
	FollowsExpression
;

FollowsExpression:
	firstEvent+=EventWithMultiplicity (events+=EventWithFollowsOperator)*;

EventWithFollowsOperator:
	operator=FollowsOperator event=FollowerEventStructure;

FollowsOperator:
	FollowsOperatorNoTW | FollowsOperatorViaTW;

FollowsOperatorNoTW:
	{FollowsOperatorNoTW}
	'->';

FollowsOperatorViaTW:
	'-[' timewindow=INT ']->';

FollowerEventStructure:
	BranchExpression | EventWithMultiplicity
;

BranchExpression:
	'('branches+=[EventTypedParameter] ('OR' branches+=[EventTypedParameter])+')'
;

EventWithMultiplicity:
	event=[EventTypedParameter]('('parameters=PatternCallParameterList?')')? ('{' multiplicity=INT '}')?;
	
PatternCallParameterList:
	{PatternCallParameterList}
	parameters+=PatternCallParameter (', ' parameters+=PatternCallParameter)*
;	

PatternCallParameter:
	{PatternCallParameter}
	name=ID
;


/*******************************************COMPLEX EVENT EXPRESSIONS*******************************************/


/*******************************************STRUCTURAL/INTEGRATION FEATURES*******************************************/
Source:
	'Source' name=ID '{'
		('register' adapter+=Adapter)+
	'}'
;

Adapter:
	name=QualifiedName
;
/*******************************************STRUCTURAL/INTEGRATION FEATURES*******************************************/